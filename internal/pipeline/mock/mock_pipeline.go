// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -destination=../mock/mock_pipeline.go -package=mock -source=interfaces.go
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	common "dolorosa/internal/pipeline/common"
	contracts "dolorosa/internal/pipeline/contracts"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockDependency is a mock of Dependency interface.
type MockDependency[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockDependencyMockRecorder[O]
}

// MockDependencyMockRecorder is the mock recorder for MockDependency.
type MockDependencyMockRecorder[O contracts.OperationData] struct {
	mock *MockDependency[O]
}

// NewMockDependency creates a new mock instance.
func NewMockDependency[O contracts.OperationData](ctrl *gomock.Controller) *MockDependency[O] {
	mock := &MockDependency[O]{ctrl: ctrl}
	mock.recorder = &MockDependencyMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDependency[O]) EXPECT() *MockDependencyMockRecorder[O] {
	return m.recorder
}

// Name mocks base method.
func (m *MockDependency[O]) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockDependencyMockRecorder[O]) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockDependency[O])(nil).Name))
}

// Resolve mocks base method.
func (m *MockDependency[O]) Resolve(ctx context.Context, state contracts.State[O]) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", ctx, state)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockDependencyMockRecorder[O]) Resolve(ctx, state any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockDependency[O])(nil).Resolve), ctx, state)
}

// SubDependencies mocks base method.
func (m *MockDependency[O]) SubDependencies() []contracts.Dependency[O] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDependencies")
	ret0, _ := ret[0].([]contracts.Dependency[O])
	return ret0
}

// SubDependencies indicates an expected call of SubDependencies.
func (mr *MockDependencyMockRecorder[O]) SubDependencies() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDependencies", reflect.TypeOf((*MockDependency[O])(nil).SubDependencies))
}

// MockRule is a mock of Rule interface.
type MockRule[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockRuleMockRecorder[O]
}

// MockRuleMockRecorder is the mock recorder for MockRule.
type MockRuleMockRecorder[O contracts.OperationData] struct {
	mock *MockRule[O]
}

// NewMockRule creates a new mock instance.
func NewMockRule[O contracts.OperationData](ctrl *gomock.Controller) *MockRule[O] {
	mock := &MockRule[O]{ctrl: ctrl}
	mock.recorder = &MockRuleMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRule[O]) EXPECT() *MockRuleMockRecorder[O] {
	return m.recorder
}

// Check mocks base method.
func (m *MockRule[O]) Check(ctx context.Context, state contracts.State[O]) common.RuleDecision {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check", ctx, state)
	ret0, _ := ret[0].(common.RuleDecision)
	return ret0
}

// Check indicates an expected call of Check.
func (mr *MockRuleMockRecorder[O]) Check(ctx, state any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockRule[O])(nil).Check), ctx, state)
}

// GetDependencies mocks base method.
func (m *MockRule[O]) GetDependencies(ctx context.Context) []contracts.Dependency[O] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDependencies", ctx)
	ret0, _ := ret[0].([]contracts.Dependency[O])
	return ret0
}

// GetDependencies indicates an expected call of GetDependencies.
func (mr *MockRuleMockRecorder[O]) GetDependencies(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDependencies", reflect.TypeOf((*MockRule[O])(nil).GetDependencies), ctx)
}

// Name mocks base method.
func (m *MockRule[O]) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockRuleMockRecorder[O]) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockRule[O])(nil).Name))
}

// ShouldRun mocks base method.
func (m *MockRule[O]) ShouldRun(ctx context.Context, operation O) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShouldRun", ctx, operation)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ShouldRun indicates an expected call of ShouldRun.
func (mr *MockRuleMockRecorder[O]) ShouldRun(ctx, operation any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShouldRun", reflect.TypeOf((*MockRule[O])(nil).ShouldRun), ctx, operation)
}

// MockRuleRegistry is a mock of RuleRegistry interface.
type MockRuleRegistry[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockRuleRegistryMockRecorder[O]
}

// MockRuleRegistryMockRecorder is the mock recorder for MockRuleRegistry.
type MockRuleRegistryMockRecorder[O contracts.OperationData] struct {
	mock *MockRuleRegistry[O]
}

// NewMockRuleRegistry creates a new mock instance.
func NewMockRuleRegistry[O contracts.OperationData](ctrl *gomock.Controller) *MockRuleRegistry[O] {
	mock := &MockRuleRegistry[O]{ctrl: ctrl}
	mock.recorder = &MockRuleRegistryMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuleRegistry[O]) EXPECT() *MockRuleRegistryMockRecorder[O] {
	return m.recorder
}

// GetRules mocks base method.
func (m *MockRuleRegistry[O]) GetRules() []contracts.Rule[O] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRules")
	ret0, _ := ret[0].([]contracts.Rule[O])
	return ret0
}

// GetRules indicates an expected call of GetRules.
func (mr *MockRuleRegistryMockRecorder[O]) GetRules() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRules", reflect.TypeOf((*MockRuleRegistry[O])(nil).GetRules))
}

// MockDependencyResolver is a mock of DependencyResolver interface.
type MockDependencyResolver[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockDependencyResolverMockRecorder[O]
}

// MockDependencyResolverMockRecorder is the mock recorder for MockDependencyResolver.
type MockDependencyResolverMockRecorder[O contracts.OperationData] struct {
	mock *MockDependencyResolver[O]
}

// NewMockDependencyResolver creates a new mock instance.
func NewMockDependencyResolver[O contracts.OperationData](ctrl *gomock.Controller) *MockDependencyResolver[O] {
	mock := &MockDependencyResolver[O]{ctrl: ctrl}
	mock.recorder = &MockDependencyResolverMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDependencyResolver[O]) EXPECT() *MockDependencyResolverMockRecorder[O] {
	return m.recorder
}

// Resolve mocks base method.
func (m *MockDependencyResolver[O]) Resolve(ctx context.Context, rules []contracts.Rule[O], state contracts.State[O]) <-chan contracts.Rule[O] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", ctx, rules, state)
	ret0, _ := ret[0].(<-chan contracts.Rule[O])
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockDependencyResolverMockRecorder[O]) Resolve(ctx, rules, state any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockDependencyResolver[O])(nil).Resolve), ctx, rules, state)
}

// MockRuleExecutor is a mock of RuleExecutor interface.
type MockRuleExecutor[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockRuleExecutorMockRecorder[O]
}

// MockRuleExecutorMockRecorder is the mock recorder for MockRuleExecutor.
type MockRuleExecutorMockRecorder[O contracts.OperationData] struct {
	mock *MockRuleExecutor[O]
}

// NewMockRuleExecutor creates a new mock instance.
func NewMockRuleExecutor[O contracts.OperationData](ctrl *gomock.Controller) *MockRuleExecutor[O] {
	mock := &MockRuleExecutor[O]{ctrl: ctrl}
	mock.recorder = &MockRuleExecutorMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuleExecutor[O]) EXPECT() *MockRuleExecutorMockRecorder[O] {
	return m.recorder
}

// ExecuteRules mocks base method.
func (m *MockRuleExecutor[O]) ExecuteRules(ctx context.Context, rules <-chan contracts.Rule[O], state contracts.State[O], rulesCnt int) <-chan common.RuleDecision {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteRules", ctx, rules, state, rulesCnt)
	ret0, _ := ret[0].(<-chan common.RuleDecision)
	return ret0
}

// ExecuteRules indicates an expected call of ExecuteRules.
func (mr *MockRuleExecutorMockRecorder[O]) ExecuteRules(ctx, rules, state, rulesCnt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteRules", reflect.TypeOf((*MockRuleExecutor[O])(nil).ExecuteRules), ctx, rules, state, rulesCnt)
}

// MockDecisionResolver is a mock of DecisionResolver interface.
type MockDecisionResolver struct {
	ctrl     *gomock.Controller
	recorder *MockDecisionResolverMockRecorder
}

// MockDecisionResolverMockRecorder is the mock recorder for MockDecisionResolver.
type MockDecisionResolverMockRecorder struct {
	mock *MockDecisionResolver
}

// NewMockDecisionResolver creates a new mock instance.
func NewMockDecisionResolver(ctrl *gomock.Controller) *MockDecisionResolver {
	mock := &MockDecisionResolver{ctrl: ctrl}
	mock.recorder = &MockDecisionResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDecisionResolver) EXPECT() *MockDecisionResolverMockRecorder {
	return m.recorder
}

// Resolve mocks base method.
func (m *MockDecisionResolver) Resolve(ctx context.Context, ch <-chan common.RuleDecision) common.FinalDecision {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", ctx, ch)
	ret0, _ := ret[0].(common.FinalDecision)
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockDecisionResolverMockRecorder) Resolve(ctx, ch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockDecisionResolver)(nil).Resolve), ctx, ch)
}

// MockPipeline is a mock of Pipeline interface.
type MockPipeline[O contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockPipelineMockRecorder[O]
}

// MockPipelineMockRecorder is the mock recorder for MockPipeline.
type MockPipelineMockRecorder[O contracts.OperationData] struct {
	mock *MockPipeline[O]
}

// NewMockPipeline creates a new mock instance.
func NewMockPipeline[O contracts.OperationData](ctrl *gomock.Controller) *MockPipeline[O] {
	mock := &MockPipeline[O]{ctrl: ctrl}
	mock.recorder = &MockPipelineMockRecorder[O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPipeline[O]) EXPECT() *MockPipelineMockRecorder[O] {
	return m.recorder
}

// Start mocks base method.
func (m *MockPipeline[O]) Start(ctx context.Context, operation O) common.FinalDecision {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx, operation)
	ret0, _ := ret[0].(common.FinalDecision)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockPipelineMockRecorder[O]) Start(ctx, operation any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockPipeline[O])(nil).Start), ctx, operation)
}

// MockState is a mock of State interface.
type MockState[T contracts.OperationData] struct {
	ctrl     *gomock.Controller
	recorder *MockStateMockRecorder[T]
}

// MockStateMockRecorder is the mock recorder for MockState.
type MockStateMockRecorder[T contracts.OperationData] struct {
	mock *MockState[T]
}

// NewMockState creates a new mock instance.
func NewMockState[T contracts.OperationData](ctrl *gomock.Controller) *MockState[T] {
	mock := &MockState[T]{ctrl: ctrl}
	mock.recorder = &MockStateMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockState[T]) EXPECT() *MockStateMockRecorder[T] {
	return m.recorder
}

// GetError mocks base method.
func (m *MockState[T]) GetError(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetError", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// GetError indicates an expected call of GetError.
func (mr *MockStateMockRecorder[T]) GetError(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetError", reflect.TypeOf((*MockState[T])(nil).GetError), name)
}

// GetExceptions mocks base method.
func (m *MockState[T]) GetExceptions(name string) []contracts.ExceptionInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetExceptions", name)
	ret0, _ := ret[0].([]contracts.ExceptionInfo)
	return ret0
}

// GetExceptions indicates an expected call of GetExceptions.
func (mr *MockStateMockRecorder[T]) GetExceptions(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExceptions", reflect.TypeOf((*MockState[T])(nil).GetExceptions), name)
}

// GetFeatures mocks base method.
func (m *MockState[T]) GetFeatures(name contracts.FeatureGroupName) []contracts.FeatureInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFeatures", name)
	ret0, _ := ret[0].([]contracts.FeatureInfo)
	return ret0
}

// GetFeatures indicates an expected call of GetFeatures.
func (mr *MockStateMockRecorder[T]) GetFeatures(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFeatures", reflect.TypeOf((*MockState[T])(nil).GetFeatures), name)
}

// GetOperation mocks base method.
func (m *MockState[T]) GetOperation() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOperation")
	ret0, _ := ret[0].(T)
	return ret0
}

// GetOperation indicates an expected call of GetOperation.
func (mr *MockStateMockRecorder[T]) GetOperation() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOperation", reflect.TypeOf((*MockState[T])(nil).GetOperation))
}

// GetStatus mocks base method.
func (m *MockState[T]) GetStatus(name string) *contracts.ResolvingStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStatus", name)
	ret0, _ := ret[0].(*contracts.ResolvingStatus)
	return ret0
}

// GetStatus indicates an expected call of GetStatus.
func (mr *MockStateMockRecorder[T]) GetStatus(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStatus", reflect.TypeOf((*MockState[T])(nil).GetStatus), name)
}

// InitStatuses mocks base method.
func (m *MockState[T]) InitStatuses(depNames []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "InitStatuses", depNames)
}

// InitStatuses indicates an expected call of InitStatuses.
func (mr *MockStateMockRecorder[T]) InitStatuses(depNames any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitStatuses", reflect.TypeOf((*MockState[T])(nil).InitStatuses), depNames)
}

// MarkResolved mocks base method.
func (m *MockState[T]) MarkResolved(name string, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MarkResolved", name, err)
}

// MarkResolved indicates an expected call of MarkResolved.
func (mr *MockStateMockRecorder[T]) MarkResolved(name, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkResolved", reflect.TypeOf((*MockState[T])(nil).MarkResolved), name, err)
}

// SetExceptions mocks base method.
func (m *MockState[T]) SetExceptions(name string, exceptions []contracts.ExceptionInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetExceptions", name, exceptions)
}

// SetExceptions indicates an expected call of SetExceptions.
func (mr *MockStateMockRecorder[T]) SetExceptions(name, exceptions any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetExceptions", reflect.TypeOf((*MockState[T])(nil).SetExceptions), name, exceptions)
}

// SetFeatures mocks base method.
func (m *MockState[T]) SetFeatures(name contracts.FeatureGroupName, features []contracts.FeatureInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetFeatures", name, features)
}

// SetFeatures indicates an expected call of SetFeatures.
func (mr *MockStateMockRecorder[T]) SetFeatures(name, features any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFeatures", reflect.TypeOf((*MockState[T])(nil).SetFeatures), name, features)
}

// WaitResolving mocks base method.
func (m *MockState[T]) WaitResolving(name string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitResolving", name)
}

// WaitResolving indicates an expected call of WaitResolving.
func (mr *MockStateMockRecorder[T]) WaitResolving(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitResolving", reflect.TypeOf((*MockState[T])(nil).WaitResolving), name)
}
